diff --git a/docs/EVICTION.md b/docs/EVICTION.md
index 93c6350..11fefdb 100644
--- a/docs/EVICTION.md
+++ b/docs/EVICTION.md
@@ -17,7 +17,11 @@ Invalidation will:
 
 * Remove from map
 * Mark chunk None in cache `zone_to_entry` reverse map
-* Keep an invalid queue (priority-queue), with each zone index and its invalid count
+* Keep an invalid queue (priority-queue (max)), with each zone index and its invalid count
 
 Eviction will:
 
+* while above low water mark
+  * pop zone from pq
+  * buffer valid chunks
+  * write valids to disk, update map
\ No newline at end of file
diff --git a/oxcache/src/device.rs b/oxcache/src/device.rs
index 40206e4..37bcafa 100644
--- a/oxcache/src/device.rs
+++ b/oxcache/src/device.rs
@@ -762,20 +762,16 @@ impl Device for BlockInterface {
     fn evict(&self, locations: EvictTarget, cache: Arc<Cache>) -> io::Result<()> {
         match locations {
             EvictTarget::Chunk(chunk_locations) => {
-                // TODO: Check units
 
                 if chunk_locations.is_empty() {
                     log::debug!("[evict:Chunk] No zones to evict");
                     return Ok(());
                 }
-                log::debug!("[evict:Chunk] Evicting zones {:?}", chunk_locations);
+                log::debug!("[evict:Chunk] Evicting chunks {:?}", chunk_locations);
 
                 RUNTIME.block_on(cache.remove_entries(&chunk_locations))?;
-                let state_mtx = Arc::clone(&self.state);
-                let _state = state_mtx.lock().unwrap();
-                // Need to change the block interface bookkeeping so
-                // that it can keep track of the list of empty chunks
-                todo!();
+
+                Ok(())
             }
             EvictTarget::Zone(locations) => {
                 if locations.is_empty() {
diff --git a/oxcache/src/zone_state/zone_list.rs b/oxcache/src/zone_state/zone_list.rs
index 5cfcf02..5db3363 100644
--- a/oxcache/src/zone_state/zone_list.rs
+++ b/oxcache/src/zone_state/zone_list.rs
@@ -23,8 +23,9 @@ pub enum ZoneObtainFailure {
 
 #[derive(Debug)]
 pub struct ZoneList {
-    pub free_zones: VecDeque<Zone>, // Unopened zones with full capacity
-    pub open_zones: VecDeque<Zone>, // Opened zones
+    pub zones: HashMap<ZoneIndex, Zone>, // Zones referenced by {free,open}_zones
+    pub free_zones: VecDeque<ZoneIndex>, // Unopened zones with full capacity
+    pub open_zones: VecDeque<ZoneIndex>, // Opened zones
     pub writing_zones: HashMap<ZoneIndex, u32>, // Count of currently writing threads
     pub chunks_per_zone: Chunk,
     pub max_active_resources: usize,
@@ -33,11 +34,12 @@ pub struct ZoneList {
 impl ZoneList {
     pub fn new(num_zones: ZoneIndex, chunks_per_zone: Chunk, max_active_resources: usize) -> Self {
         // List of all zones, initially all are "free"
-        let avail_zones = (0..num_zones)
-            .map(|index| Zone {
-                index,
-                chunks_available: (0..chunks_per_zone).rev().collect(),
-            })
+        let avail_zones = (0..num_zones).collect();
+        let zones = (0..num_zones)
+            .map(|item| (item, Zone {
+                index: item,
+                chunks_available: (0..num_zones).rev().collect()
+            })) // (key, value)
             .collect();
 
         ZoneList {
@@ -46,6 +48,7 @@ impl ZoneList {
             writing_zones: HashMap::with_capacity(max_active_resources),
             chunks_per_zone,
             max_active_resources,
+            zones,
         }
     }
 
@@ -56,6 +59,7 @@ impl ZoneList {
             return Err(EvictNow);
         }
 
+        // Open first if possible
         let can_open_more_zones =
             self.get_open_zones() < self.max_active_resources && self.free_zones.len() > 0;
 
@@ -76,11 +80,14 @@ impl ZoneList {
         }
 
         let zone = if can_open_more_zones {
-            let res = self.free_zones.pop_front();
-            log::debug!("[ZoneList]: Opening zone {}", res.as_ref().unwrap().index);
-            res
+            // Open a new zone
+            let res = self.free_zones.pop_front().unwrap();
+            log::debug!("[ZoneList]: Opening zone {}", res);
+            self.zones.get_mut(&res)
         } else {
-            let res = self.open_zones.pop_front();
+            // Grab an existing zone
+            let res = self.open_zones.pop_front().unwrap();
+            let res = self.zones.get_mut(&res);
             log::debug!(
                 "[ZoneList]: Using existing zone {} with {:?} chunks",
                 res.as_ref().unwrap().index,
@@ -88,8 +95,8 @@ impl ZoneList {
             );
             res
         };
+
         let mut zone = zone.unwrap();
-        
         let zone_index = zone.index;
 
         if zone.chunks_available.len() <= 0 {
@@ -98,10 +105,10 @@ impl ZoneList {
 
         zone.chunks_available.pop();
         if zone.chunks_available.len() >= 1 {
-            log::debug!("[ZoneList]: Returning zone back to use: {}", zone.index);
-            self.open_zones.push_back(zone);
+            log::debug!("[ZoneList]: Returning zone back to use: {}", zone_index);
+            self.open_zones.push_back(zone_index);
         } else {
-            log::debug!("[ZoneList]: Not returning zone back to use: {}", zone.index);
+            log::debug!("[ZoneList]: Not returning zone back to use: {}", zone_index);
         }
 
         self.writing_zones
@@ -178,11 +185,11 @@ impl ZoneList {
         } else {
             self.open_zones.pop_front()
         };
-        let mut zone = zone.unwrap();
-        let zone_index = zone.index;
+        let zone_index = zone.unwrap();
+        let mut zone = self.zones.get_mut(&zone_index).unwrap();
         let chunk = zone.chunks_available.pop().unwrap();
         if zone.chunks_available.len() >= 1 {
-            self.open_zones.push_back(zone);
+            self.open_zones.push_back(zone_index);
         }
 
         Ok(ChunkLocation {
@@ -191,6 +198,30 @@ impl ZoneList {
         })
     }
 
+    pub fn return_chunk_location(&mut self, chunk: ChunkLocation) -> Result<(), ZoneObtainFailure> {
+        // let can_open_more_zones =
+        //     self.open_zones.len() < self.max_active_resources && self.free_zones.len() > 0;
+        //
+        // let zone = if can_open_more_zones {
+        //     self.free_zones.pop_front()
+        // } else {
+        //     self.open_zones.pop_front()
+        // };
+        // let mut zone = zone.unwrap();
+        // let zone_index = zone.index;
+        // let chunk = zone.chunks_available.pop().unwrap();
+        // if zone.chunks_available.len() >= 1 {
+        //     self.open_zones.push_back(zone);
+        // }
+        //
+        // Ok(ChunkLocation {
+        //     zone: zone_index,
+        //     index: chunk,
+        // })
+
+        Ok(())
+    }
+
     // Check if all zones are full
     pub fn is_full(&self) -> bool {
         self.free_zones.is_empty() && self.open_zones.is_empty()
@@ -199,14 +230,9 @@ impl ZoneList {
     // Gets the number of open zones by counting the unique
     // zones listed in open_zones and writing_zones
     pub fn get_open_zones(&self) -> usize {
-        // TODO: This is slow, O(n)
-
-        // I don't think it's super slow because there will be at most
-        // 2 * max_active_resources zones.
         let open_zone_list = self
             .open_zones
             .iter()
-            .map(|zone| &zone.index)
             .collect::<HashSet<&ZoneIndex>>();
 
         self.writing_zones
@@ -225,15 +251,10 @@ impl ZoneList {
     ) -> std::io::Result<()> {
         debug_assert!(!self.writing_zones.contains_key(&idx));
 
-        debug_assert!({
-            let mut zone_indices = self.open_zones.iter().map(|zone| zone.index);
-            !zone_indices.any(|zidx| zidx == idx)
-        });
+        let zone = self.zones.get_mut(&idx).unwrap();
+        zone.chunks_available = (0..self.chunks_per_zone).rev().collect();
 
-        self.free_zones.push_back(Zone {
-            index: idx,
-            chunks_available: (0..self.chunks_per_zone).rev().collect(),
-        });
+        self.free_zones.push_back(idx);
 
         device.reset_zone(idx)
     }
@@ -251,10 +272,25 @@ impl ZoneList {
     }
 
     pub fn get_num_available_chunks(&self) -> Chunk {
-        self.open_zones
+        // Total available chunks in open zones
+        let open_zone_chunks: Chunk = self
+            .open_zones
             .iter()
-            .fold(0, |avail, zone| avail + zone.chunks_available.len() as Chunk)
-            + (self.free_zones.len() as ZoneIndex * self.chunks_per_zone)
+            .map(|zone_index| {
+                // Look up the Zone struct for this zone index
+                let zone = self.zones.get(zone_index).unwrap();
+
+                // Count how many chunks are still available in this zone
+                zone.chunks_available.len() as Chunk
+            })
+            .sum();
+
+        // Total available chunks in completely free zones
+        let free_zone_chunks: Chunk =
+            (self.free_zones.len() as Chunk) * self.chunks_per_zone;
+
+        // Grand total
+        open_zone_chunks + free_zone_chunks
     }
 }
 
